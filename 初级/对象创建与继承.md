## 1.工厂模式
优缺点：
    可以无数次调用这个工厂模式，每次都会返回一个包含固定属性与方法的对象。工厂模式最大的问题是无法识别对象类型。
```typescript
    function createObj(config){
        let obj=new Object()
        obj.name=config.name
        obj.func=function(){
            console.log(this.name)
        }
        return obj
    }
    let mockObj=createObj({name:"age"})
```

## 2.构造函数模式
优缺点：
    没有显示的创建对象，使用new来调用这个方法。使用这个方式创建对象可以检测对象类型。但是，每个方法都会在实例上创建一次，严重浪费内存。
```typescript
    function Obj(config){
        this.name=config.name
        this.func=function(){
            console.log(this.name)
        }
    }
    let mockObj=new Obj({name:"d"})
```

## 3.原型模式
优缺点：
    将信息直接添加到原型对象上，所有的实例对象共享它所包含的属性与方法，不必在构造函数中定对象的实例信息。
```typescript
    function Obj(){}
    Obj.prototype.name='example'
    Obj.prototype.func=function(){
        console.log(this.name)
    }
    let mockObj=new Obj()
```

## 4.混合构造函数和原型模式
优缺点：
    每一个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度的节省了内存。
```typescript
    function Obj(config){
        this.name=config?config.name|"test"
    }
    Obj.prototype.func=function(){
        console.log(this.name)
    }
    let mockObj=new Obj()
```
## 5.拷贝继承
优缺点：
 - 需要使用call修改this指向
 - 对象复制存在引用问题，其中一个原型修改会影响另一个
 ```typescript
    function Create(){
        this.name="age"
    }
    Create.prototype.dis=function(){
        console.log(this.name)
    }
    function Create2(){
        Create.call(this)
        this.age=12
    }
    Create2.prototype=Create.prototype
 ```

## 6.原型链继承
优缺点：
 - 
  ```tyepscirpt
    function Animal(){
        this.name=[1,23,4]
     }
     Animal.prototype.eat=function(){
         console.log(this.name)
     }
     function Bbb(){}
     Bbb.prototype =new Animal()
  ```